{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019-07-31-ai-for-fe/","webpackCompilationHash":"c67fd189b220c7198953","result":{"data":{"site":{"siteMetadata":{"title":"Ten's Thoughts","author":"Ten Zhi Yang"}},"markdownRemark":{"id":"82d7a0ea-60e8-5833-b955-dd36baad042f","excerpt":"This article is a complement to my presentation in React Knowledgable. Introduction Artificial Intelligence is all the rage now, with the craze starting from…","html":"<p><strong>This article is a complement to my presentation in React Knowledgable.</strong></p>\n<h2>Introduction</h2>\n<p>Artificial Intelligence is all the rage now, with the craze starting from Deepmind’s alpha go. Although I hate people for misusing the terms “artificial intelligence” and “machine learning” for things that do not need AI and ML to solve, I do think that using AI reduces the time taken to solve certain problems, and also can add some “WoW factor” to an idea. I hope with this article (and subsequent presentations) people will understand what kind of problems that AI can solve, and maybe make AI more approachable so that the overall quality of hackathon projects improve.</p>\n<p>First off, a disclaimer: <strong>I am by no means an expert in AI. I do have an undergrad level understanding of artificial intelligence, but I was never great at it.</strong> Feel free to correct me on any wrong concepts that I write in this article. I will also try to explain AI in English and not technobable, so for the real AI masters out there, you might cringe at me using wrong analogies or even butchering terminologies in an attempt to make AI easier to understand.</p>\n<p>My motivation for this article stems from two comments that irks me. These (paraphrased) comments come from people who I think are smarter and better engineers than me. We are all front end engineers, and I can understand why they said it, but all these were in the context of Hackathons, and I feel that it’s a shame for people to be limited in implementation just because AI seems so daunting.</p>\n<blockquote>\n<p>You can use my idea because I don’t know how to build it</p>\n</blockquote>\n<p>This came from a very creative person whose idea not only allowed me to win the second prize, they also won a consolation prize in their idea. People say ideas are cheap. That’s half true. Yes, there is likely someone else who stumbled across the same idea and has the skills to implement it, but really most of the time we already have the capacity to build this idea, we just don’t know it yet. </p>\n<blockquote>\n<p>I wish I did more AI related things in University, I feel like I missed out</p>\n</blockquote>\n<p>This is <strong>the</strong> comment that prompted me to come up with this article. I always wanted to present something about AI to my team, given that I do have <em>some</em> understanding of AI, but someone else did an introduction to Neural Networks that was more detailed than what I could come up with and I felt that that person would be more suited to carry on doing AI related talks. However from this comment I realised that <strong>because</strong> I am kinda shit in AI, but yet I know how to <strong>use</strong> AI libraries, I can add value to this topic. </p>\n<p>So here’s what I hope people will gain from this article:</p>\n<ul>\n<li>Approaching Problems with AI</li>\n<li>What algorithms are good to google</li>\n<li>What can we achieve with just a surface level knowledge of AI</li>\n<li>Famous APIs that we can use for the next hackathon/prototype of things that we wanna work on</li>\n</ul>\n<p>Here’s what I will <strong>not</strong> go through</p>\n<ul>\n<li>How Neural networks work</li>\n<li>How to build an AI from scratch</li>\n<li>How to beat the no.1 go player with AI</li>\n<li>How famous algorithms work</li>\n<li>How to win a hackathon with AI</li>\n</ul>\n<p>Mostly because I don’t know the answers to any of the above.</p>\n<p>Now this article will be written with FE developers in mind, with introductions to Javascript libraries. Many people would say that there are a lot of better languages for AI development and I entirely agree. There are some benefits to do AI in Javascript. Firstly, there’s always the Nodes argument: your entire stack can be the same language. Whatever flavour of JS you are using, you can easily switch over from one to another. This is great for a quick prototype and/or proof of concept to show that your idea even works in the first place. Secondly for the users, you can have the entire script running on the browser. You can write some application once and run it anywhere, you don’t have to worry about scaling as all the computation is running on the user’s device. This also means you can have your application runnning offline, with PWAs. I think this is one of the strongest points we have for AI running on browsers. Finally, in terms of performance, JS is not much behind python, in some cases it might even been faster. It’s really only a matter of time before the tools available for JS catches up to Python as the JS community grows larger and larger.</p>\n<h2>What is AI</h2>\n<p>There are a few definitions of what AI is, and many of us get confused about the terminology. What is Artificial Intelligence and what is Machine Learning? Are they even different? The most sensible definition I found is that Artificial Intelligence is <code class=\"language-text\">Simulation of human thought processes in machines.</code> I find this to be very accurate. AI can be as simple as a bunch of if-else statements (that’s essentially a <code class=\"language-text\">decision tree</code>) or something as complicated as simulating a brain (<code class=\"language-text\">neural nets</code>). Machine learning is a subset of artificial intelligence, and basically what ML does is to write a program to find patterns in data, without being explicitly written which pattern to recognise.</p>\n<p>Now in my own understanding, we really just want to solve three different types of problems:</p>\n<ul>\n<li>Categorise things</li>\n<li>Make Decisions</li>\n<li>Generate things</li>\n</ul>\n<p>These groups of problems are actually not how actual AI-savvy people group them, but I find these approach of grouping problems easier to use to visualise solving some problem with AI.</p>\n<p>These problems have to be represented by some form of data, so that’s something that usually requires some level of intuition and experience, but after a while you might start recognising certain methods people use to represent different data. For now, let’s assume that all real world data come in the form of numbers stored in some variables.</p>\n<h2>Categorising problem</h2>\n<p>For the first type of problems, we can imagine a mathamatical function. Suppose we want to guess: given a Merge Request (Pull Request) how many people will actually do a MR vs giving a “free” <code class=\"language-text\">LGTM</code>? In this case, maybe a point of interest would be the length of the MR by lines of code changed. We can expect that with more lines, the more likely people will <code class=\"language-text\">LGTM</code> it without reading it. Now maybe a second point of interest that we want to do is how many files have been changed. Now if there’s very few file changes, the code change is easier to understand, and people will tend to actually review the code compared to MRs with lots of file change. So we end up with something like this:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/ac238eb1b7ab61a0f7f2463db59bb051/b9e4f/datapoint.png\"/></p>\n<p>So what we want our algorithm to do is to draw some line such that everything above the line belongs to <code class=\"language-text\">LGTM</code>-ed category, and everything below the line belongs to the <code class=\"language-text\">actually been reviewed</code> category. So we pass these data into some categorising function and it will generate a best-fit line. Now whenever we want to categorise a new MR, we just plot it on the graph and check its relation to the said line like so:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/f8c3ca700bab95a2c5dd2607e5c5499a/b9e4f/newdatapoint.png\"/></p>\n<p>But that is just two variables, what if we want to have a third variable? Like for example, how near is the deadline? The nearer the deadline, the more likely someone will skim through it, the further it is, the more likely someone will read it through. Well for 3 parameters, we can actually visualise it as a point in a 3-dimensional space. Instead of a line, we will separate the dataset with what we call a plane (that is, a 2-d surface that extends indefinitely), like so:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/b06ebc757eb5b3db32071b04750708fd/c739e/plane.jpg\"/></p>\n<p>If we add another variable? Easy! Make it four dimensional, or five, or six or however many variables you need. In ML we call these variables <code class=\"language-text\">parameters</code> and we call the thing separating the different categories the <code class=\"language-text\">hyperplane</code> (subspace whose dimension is one less than that of its ambient space). Not all categorising algorithms work like this, but this is a way to visualise your problem that you want to solve.</p>\n<h2>Decision making problem</h2>\n<p>Next kind of problem, we have decision making. Essentially, given some number of choices, we want to be able to choose the most desirable option. A case study for this kind of problem would be something like a Tetris playing bot. Let’s establish some rules of the Tetris that we’re going to analyse. This will keep our problem scope smaller and easier to analyse.</p>\n<ul>\n<li>your score is how many lines you clear (one line, one point)</li>\n<li>how fast you make the move doesnt matter</li>\n<li>you only know the current piece, and the current state of the game</li>\n</ul>\n<p>So let’s think, how we would want <em>a robot</em> to play this game. I added the words <em>a robot</em> there for one simple reason. We don’t want to care about things that will affect us emotionally. We are aware that the game gives us four points if we clear four lines in one go, and four points if we clear four lines individually, but for us it will feel so much more satisfying if we were clearing four lines at one go. Similarly, we don’t want the robot to care if making the optimal move makes the state of the game look “ugly”, we only care if its the best move at the current point in time.</p>\n<p>What we’ll do is given a current state of the game, we want to place the moves in every single possible(legal) ways and then use some method to gauge if a move is good or not. So what is this method? We will take the state of the game, and then come up with some numbers to represent a desirable trait or an undesirable trait. We will then sum up the desirable traits, and minus the undesirable traits to get a score. These traits are known as <code class=\"language-text\">heuristics</code>. Heuristics give us some interpretation of how good a decision is, and more importantly, they are usually fast to calculate. Of course, some traits are more important than others, so we need to multiply them by some constant value. These constant values are called <code class=\"language-text\">weights</code>. We can throw the weights into some classification algorithm to optimise what number is better, so we don’t need to care about what the numbers are for the sake of this article.</p>\n<p>Let’s think of the first heuristic we care about. Of course we want to clear lines, and even though clearing more lines doesn’t give us more points, but it makes the game last a little bit longer, so let’s just count if there are lines cleared or not this turn:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/b5b202697ba2915bed68d75bad0c7596/c739e/linesclear.jpg\"/></p>\n<p>Next thing, we want the robot to play as many moves as possible, so that it has the most chances to clear lines, we don’t want the bot to make an optimal move it that ends the game right now. So let’s take something like, the current height of the game like so:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/ba095da270fa5c0e70f815fcd35a149c/c739e/height.jpg\"/></p>\n<p>Now this is good, but suppose we have just one line that’s really tall but doesnt lose immediately, that’s not entirely bad right? So maybe we can do something better. instead of just height, let’s sum up the height of each individual column, like this:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/2cc87472321eb3eb7805522ad7be660e/c739e/colheight.jpg\"/></p>\n<p>Finally the biggest bane of Tetris is to have a “hole” right? it’s bound to happen but we want to reduce the number of holes. Lets count the number of holes and then multiply it by a some negative weight:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/b4f9d1896a761a1cd7acfb2667b239bd/c739e/holes.jpg\"/></p>\n<p>But it’s not neccessarily just holes, overhanging piece will eventually create holes (assume no T-spins and no “sliding” at the bottom) so we want to count that as well. And a hole with more overhang is worse than a piece that just overhangs. So let’s do something like this:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/5780c3d471812030d953998ea2c1733f/c739e/overhang.jpg\"/></p>\n<p>If we look at the previous two, isn’t the hole count really some subset of the overhang count? So maybe we can do something better. How about if starting from bottom, we add a count everytime we go from “solid” to “gap” this way we can actually detect when there are a lot of small gaps, as small gaps take more moves to solve but big gaps could be solved easier.</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/2f51a4fccdefb0b72239ebc5ecff6e8d/c739e/bumpiness.jpg\"/></p>\n<p>But I think we can do better. This heuristics takes care of how many gaps there are in the same column, but it doesn’t really have a big picture representation of how sever a gap is. A gap with many bends is much harder to solve than a ‘smooth’ gap. A heuristic that can take this into consideration could be something like how many 90 degree bends there are in the state.</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/b3e97bff0c717846a1295184fc097d67/c739e/bends.jpg\"/></p>\n<p>Summing up the heuristics and then multiplying by some constant weights to them, we have something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">c_1 * linesCleared + (-1 * c_2) * sumColHeight + (-1 * c_3) * numBends</code></pre></div>\n<p>So now we have a bot that analyses Tetris like how an almost perfect human would, except the analysis needs to be weighted. All details aside, we can look for some algorithm that takes in <code class=\"language-text\">c_1, c_2, c_3</code>, runs a game of Tetris, gets the score, modifies <code class=\"language-text\">c_1, c_2, c_3</code> a little bit and runs the game again. rinse and repeat until <code class=\"language-text\">c_1, c_2, c_3</code> is fairly stagnant, or you don’t have time to train anymore. In unviversity my teammates used a library which provided something called <code class=\"language-text\">particle swarm optimisation</code> which brought my team’s AI score up from ten thousands to millions just by running a optimisation algorithm on the weights.</p>\n<h2>Content Generation Problem</h2>\n<p>For the final type of problem, unfortunately there are too many different ways for diffent domains. Generating an Image is quite different from generating sounds or text. There is some headway being made in the form of neural networks which pit two neural networks against each other, but that’s a whole new article and presentation. However for text generation, there are some probability-based state machines (known as <code class=\"language-text\">Markov model</code> or <code class=\"language-text\">Markov process</code>) that is easy to program, and also gives us reasonable results.</p>\n<p>I won’t go through the process of writing a <code class=\"language-text\">Markov model</code> but the general idea for text generation will be something like. “What is the most likely word to appear next, given that the words before are <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> (and <code class=\"language-text\">c</code> and <code class=\"language-text\">d</code> etc etc etc..)?” So what we will do is to find a markov model, and find sufficiently big dataset. An example that I want to use is something like a Donald Trump text generator. </p>\n<p>First things first, I need a dataset. In the domain of Natural Language Processing, we call a file with lots of sentances a corpus, so I found <a href=\"https://github.com/ryanmcdermott/trump-speeches\">1mb worth of trump speeches</a> from <a href=\"https://twitter.com/ryconoclast\">@ryconoclast</a>. We can do some cleanining up of the data, like changing all text to lowercase, and grouping words that come from the same word together(<code class=\"language-text\">stemming</code>, eg: consultant, consulting, consults -> consult) but I won’t be using it for my example, just to showcase how decent the results are without much effort.</p>\n<p>After finding <a href=\"https://medium.com/@corrigan1247/how-to-imitate-trump-with-markov-chains-8224877dcf69\">a tutorial on how to do exactly trump speech generators</a>, I passed in the entire text file into the function, added some checks to make my generated content at least 20 words long, and this is my result:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/493d544d615b06d81ba9320aa313b80e/ef8bc/2gram.png\"/></p>\n<p>Not too bad, but a little bit random right? If you did read through the tutorial on building Markov chains, you might guess why. If not, the general idea is that we are only looking at some word <code class=\"language-text\">a</code> and getting a list of words that come after <code class=\"language-text\">a</code>, and choosing a word randomly from there. This is kinda funny but not really as fluent as we like it to be. So I did some modifications and made it such that we get a sequence of <code class=\"language-text\">x</code> number of words to generate the next one. So here’s one where we look at the previous 2 words:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/f73270bd07bba4e4b81803120f474bcf/67648/3gram.png\"/></p>\n<p>Pretty good! increasing the number of words we reference:</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/2b8d20ea7d6509aeda829807440bb282/22492/4gram.png\"/>\n<img class=\"gatsby-remark-images-extra\" src=\"/static/56da2c78e8a0a94c2008364c859f63c1/26532/5gram.png\"/>\n<img class=\"gatsby-remark-images-extra\" src=\"/static/66c7aab144b3ab93b80b8514581923b4/ab8e7/6gram.png\"/></p>\n<p>Woah, that last one seems a bit too on the nose doesn’t it? That’s because it’s directly lifted from the source.</p>\n<p><img class=\"gatsby-remark-images-extra\" src=\"/static/f9c9fdd09306e8d0b8efe0ccf6d8b99b/b9e4f/corpus.png\"/></p>\n<p>So here lies a decision we must make. The more fluent we want our robot to be, the more previous words we want to use to predict the next words. However the more words we use, the more we directly lift from the source text. I find that a good number of previous words to look back on is between 1 to 3. You can try the <a href=\"https://httpserve.tenzhiyang.com/gumshoos/\">gumshoos speech generator</a> with 2 previous words (bi-gram).</p>\n<p>That’s three different case studies of analysing three different AI solvable problems, (mis)quoting portal: now you’re thinking in AI, with this Part 1 I hope you manage to gain some insight on how people approach real world problems and breaking them down into numbers, then trying to solve it in one of the three above methods. It comes with practice and there are definitely more than one way to categorise, make decisions or generate problems, so keep at it, get to know more AI tools available and you can evantually make great AI applications in a short period of time!</p>","frontmatter":{"title":"AI for FE devs (Part 1)","date":"July 31, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-07-31-ai-for-fe/","previous":{"fields":{"slug":"/2019-07-19-a-race-cond-in-react-redux/"},"frontmatter":{"title":"A race condition in react-redux"}},"next":{"fields":{"slug":"/2019-08-01-ai-for-fe-2/"},"frontmatter":{"title":"AI for FE devs (Part 2)"}}}}}